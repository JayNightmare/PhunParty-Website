const CACHE_NAME = "phunparty-v1.0.0";
const OFFLINE_CACHE = "phunparty-offline-v1.0.0";

// Resources to cache for offline use
const CORE_CACHE_RESOURCES = [
    "/",
    "/manifest.json",
    "/index.html",
    // Add main CSS and JS bundles (these will be generated by Vite)
];

// Resources that should work offline
const OFFLINE_FALLBACK_RESOURCES = ["/offline.html"];

// Install event - cache core resources
self.addEventListener("install", (event) => {
    console.log("[SW] Install event");

    event.waitUntil(
        Promise.all([
            // Cache core resources
            caches
                .open(CACHE_NAME)
                .then((cache) => {
                    console.log("[SW] Caching core resources");
                    return cache.addAll(CORE_CACHE_RESOURCES);
                })
                .catch((error) => {
                    console.warn(
                        "[SW] Failed to cache some core resources:",
                        error
                    );
                }),

            // Cache offline fallbacks
            caches
                .open(OFFLINE_CACHE)
                .then((cache) => {
                    console.log("[SW] Caching offline fallbacks");
                    return cache.addAll(OFFLINE_FALLBACK_RESOURCES);
                })
                .catch((error) => {
                    console.warn(
                        "[SW] Failed to cache offline resources:",
                        error
                    );
                }),
        ]).then(() => {
            // Force activation of new service worker
            return self.skipWaiting();
        })
    );
});

// Activate event - cleanup old caches
self.addEventListener("activate", (event) => {
    console.log("[SW] Activate event");

    event.waitUntil(
        Promise.all([
            // Clean up old caches
            caches.keys().then((cacheNames) => {
                return Promise.all(
                    cacheNames.map((cacheName) => {
                        if (
                            cacheName !== CACHE_NAME &&
                            cacheName !== OFFLINE_CACHE
                        ) {
                            console.log("[SW] Deleting old cache:", cacheName);
                            return caches.delete(cacheName);
                        }
                    })
                );
            }),

            // Take control of all clients immediately
            self.clients.claim(),
        ])
    );
});

// Fetch event - implement caching strategy
self.addEventListener("fetch", (event) => {
    const { request } = event;
    const url = new URL(request.url);

    // Skip non-GET requests
    if (request.method !== "GET") {
        return;
    }

    // Skip chrome-extension and other non-http requests
    if (!url.protocol.startsWith("http")) {
        return;
    }

    // Handle API requests - network first with fallback
    if (url.pathname.startsWith("/api")) {
        event.respondWith(networkFirstWithFallback(request));
        return;
    }

    // Handle app shell - cache first
    if (isAppShellRequest(url.pathname)) {
        event.respondWith(cacheFirstWithNetworkFallback(request));
        return;
    }

    // Handle assets - cache first with network fallback
    if (isAssetRequest(url.pathname)) {
        event.respondWith(cacheFirstWithNetworkFallback(request));
        return;
    }

    // Default: network first with cache fallback
    event.respondWith(networkFirstWithFallback(request));
});

// Caching strategies
async function networkFirstWithFallback(request) {
    try {
        // Try network first
        const networkResponse = await fetch(request);

        // If successful, update cache and return response
        if (networkResponse.ok) {
            const cache = await caches.open(CACHE_NAME);
            cache.put(request, networkResponse.clone()).catch(() => {
                // Ignore cache errors
            });
        }

        return networkResponse;
    } catch (error) {
        // Network failed, try cache
        console.log("[SW] Network failed, trying cache for:", request.url);
        const cachedResponse = await caches.match(request);

        if (cachedResponse) {
            return cachedResponse;
        }

        // If it's a navigation request, return offline fallback
        if (request.mode === "navigate") {
            const offlineResponse = await caches.match("/offline.html");
            if (offlineResponse) {
                return offlineResponse;
            }
        }

        // Return network error
        throw error;
    }
}

async function cacheFirstWithNetworkFallback(request) {
    // Try cache first
    const cachedResponse = await caches.match(request);

    if (cachedResponse) {
        // Update cache in background
        fetch(request)
            .then((response) => {
                if (response.ok) {
                    const cache = caches.open(CACHE_NAME);
                    cache
                        .then((c) => c.put(request, response.clone()))
                        .catch(() => {
                            // Ignore cache errors
                        });
                }
            })
            .catch(() => {
                // Ignore network errors in background update
            });

        return cachedResponse;
    }

    // Cache miss, try network
    try {
        const networkResponse = await fetch(request);

        if (networkResponse.ok) {
            const cache = await caches.open(CACHE_NAME);
            cache.put(request, networkResponse.clone()).catch(() => {
                // Ignore cache errors
            });
        }

        return networkResponse;
    } catch (error) {
        // Both cache and network failed
        throw error;
    }
}

// Helper functions
function isAppShellRequest(pathname) {
    return (
        pathname === "/" ||
        pathname === "/index.html" ||
        pathname.startsWith("/join") ||
        pathname.startsWith("/account") ||
        pathname.startsWith("/new-session")
    );
}

function isAssetRequest(pathname) {
    return (
        pathname.startsWith("/assets/") ||
        pathname.startsWith("/icons/") ||
        pathname.endsWith(".js") ||
        pathname.endsWith(".css") ||
        pathname.endsWith(".png") ||
        pathname.endsWith(".jpg") ||
        pathname.endsWith(".svg") ||
        pathname.endsWith(".woff") ||
        pathname.endsWith(".woff2")
    );
}

// Handle push notifications (future feature)
self.addEventListener("push", (event) => {
    if (!event.data) return;

    const data = event.data.json();

    const options = {
        body: data.body || "New notification from PhunParty",
        icon: "/icons/icon-192x192.png",
        badge: "/icons/icon-72x72.png",
        tag: data.tag || "phunparty-notification",
        data: data.data || {},
        actions: data.actions || [],
    };

    event.waitUntil(
        self.registration.showNotification(data.title || "PhunParty", options)
    );
});

// Handle notification clicks
self.addEventListener("notificationclick", (event) => {
    event.notification.close();

    const data = event.notification.data;

    event.waitUntil(self.clients.openWindow(data.url || "/"));
});
